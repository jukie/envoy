syntax = "proto3";

package envoy.extensions.load_balancing_policies.common.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.common.v3";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3;commonv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common configuration for two or more load balancing policy extensions]

message LocalityLbConfig {
  // Configuration for :ref:`zone aware routing
  // <arch_overview_load_balancing_zone_aware_routing>`.
  // [#next-free-field: 8]
  message ZoneAwareLbConfig {
    // Basis for computing per-locality percentages in zone-aware routing.
    enum LocalityBasis {
      // Use the number of healthy hosts in each locality.
      HEALTHY_HOSTS_NUM = 0;

      // Use the weights of healthy hosts in each locality.
      HEALTHY_HOSTS_WEIGHT = 1;

      // Use ORCA backend load metrics to make routing decisions based on upstream utilization.
      // This mode aggregates ORCA load reports (CPU utilization, application utilization)
      // across all hosts in each locality to determine actual backend utilization.
      //
      // Routing behavior:
      // - Routes 100% locally (LocalityDirect) if local zone utilization is not significantly
      //   higher than other zones (within locality_direct_threshold, default 5%)
      // - Otherwise distributes traffic inversely proportional to utilization to equalize
      //   load across zones (zones with lower utilization receive more traffic)
      //
      // This addresses the limitation of standard zone-aware routing which assumes evenly
      // distributed incoming traffic. With ORCA, overloaded zones automatically send traffic
      // to less-loaded zones to achieve equal utilization.
      //
      // Requires backends to emit ORCA load reports.
      // See :ref:`ORCA load based config <envoy_v3_api_msg_extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig.OrcaLoadBasedConfig>`
      ORCA_LOAD = 2;
    }

    // Configures Envoy to always route requests to the local zone regardless of the
    // upstream zone structure. In Envoy's default configuration, traffic is distributed proportionally
    // across all upstream hosts while trying to maximize local routing when possible. The approach
    // with force_local_zone aims to be more predictable and if there are upstream hosts in the local
    // zone, they will receive all traffic.
    // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    message ForceLocalZone {
      // Configures the minimum number of upstream hosts in the local zone required when force_local_zone
      // is enabled. If the number of upstream hosts in the local zone is less than the specified value,
      // Envoy will fall back to the default proportional-based distribution across localities.
      // If not specified, the default is 1.
      // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
      // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
      google.protobuf.UInt32Value min_size = 1;
    }

    // Configures percentage of requests that will be considered for zone aware routing
    // if zone aware routing is configured. If not specified, the default is 100%.
    // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    type.v3.Percent routing_enabled = 1;

    // Configures minimum upstream cluster size required for zone aware routing
    // If upstream cluster size is less than specified, zone aware routing is not performed
    // even if zone aware routing is configured. If not specified, the default is 6.
    // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    google.protobuf.UInt64Value min_cluster_size = 2;

    // If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
    // mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
    // requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
    // failing service.
    bool fail_traffic_on_panic = 3;

    // If set to true, Envoy will force LocalityDirect routing if a local locality exists.
    bool force_locality_direct_routing = 4
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    ForceLocalZone force_local_zone = 5;

    // Determines how locality percentages are computed:
    // - HEALTHY_HOSTS_NUM: proportional to the count of healthy hosts.
    // - HEALTHY_HOSTS_WEIGHT: proportional to the weights of healthy hosts.
    // - ORCA_LOAD: proportional to backend load metrics from ORCA reports.
    // Default value is HEALTHY_HOSTS_NUM if unset.
    LocalityBasis locality_basis = 6;

    // Configuration for ORCA-based locality load balancing.
    // Only used when locality_basis is set to ORCA_LOAD.
    // [#next-free-field: 11]
    message OrcaLoadBasedConfig {
      // Specifies which ORCA utilization metrics to use for measuring backend load.
      // Metrics are evaluated in priority order - the first valid metric is used.
      // This mirrors the approach used by client-side weighted round robin.
      message UtilizationMetrics {
        // Custom utilization metric names to evaluate in priority order.
        // These map to entries in the ``named_metrics`` map of ORCA load reports.
        // Example: ["backend_queue_depth", "db_connection_pool_utilization", "memory_utilization"]
        repeated string metric_names = 1;

        // Whether to use application_utilization as the primary metric.
        // If true, application_utilization is checked first before custom metrics.
        // Default: true.
        bool use_application_utilization = 2;

        // Whether to use cpu_utilization as the final fallback metric.
        // If true, cpu_utilization is used when no other metrics are available.
        // Default: true.
        bool use_cpu_utilization = 3;
      }

      // ORCA utilization metrics configuration.
      // Defines the hierarchy of metrics to use for determining backend load.
      // Default is to use application_utilization first, then cpu_utilization as fallback.
      UtilizationMetrics utilization_metrics = 1;

      // Penalty multiplier for error rate when calculating utilization.
      // Higher values penalize endpoints with more errors more heavily.
      // Formula: effective_utilization = base_utilization + (error_rate * error_utilization_penalty)
      // Default: 1.0 (same penalty as client-side weighted round robin).
      google.protobuf.DoubleValue error_utilization_penalty = 2;

      // How often to refresh zone-level ORCA metrics weights.
      // Aligns with client-side weighted round robin's weight_update_period.
      // When zone metrics become stale (older than this period), they are recalculated
      // on-demand during request routing. This lazy update strategy ensures metrics
      // stay fresh during active traffic without requiring background timers.
      // Defaults to 1 second. Values less than 100ms are capped at 100ms.
      google.protobuf.Duration weight_update_period = 3;

      // Minimum number of hosts in a locality that must be reporting ORCA data
      // before the aggregated zone metrics are considered valid.
      // If fewer hosts are reporting, the locality falls back to the configured
      // ``fallback_basis`` for weight calculation.
      // Default is 3 hosts.
      google.protobuf.UInt32Value min_reporting_hosts_per_zone = 4
          [(validate.rules).uint32 = {gte: 1}];

      // The locality basis to use when ORCA data is insufficient or unavailable.
      // This happens when:
      // - Fewer than min_reporting_hosts_per_zone hosts are reporting ORCA data
      // - ORCA data is stale or invalid
      // - Hosts don't support ORCA reporting
      // Default is HEALTHY_HOSTS_NUM.
      LocalityBasis fallback_basis = 5;

      // Threshold for LocalityDirect routing when using ORCA_LOAD.
      // Routes 100% locally (LocalityDirect mode) if local zone utilization is not
      // significantly higher than the least-utilized zone.
      //
      // Example with threshold of 0.05 (5%):
      // - Local zone: 60% utilization
      // - Zone A: 55% utilization (least-utilized)
      // - Zone B: 70% utilization
      // - Difference: 60% - 55% = 5% (within threshold) → Route 100% locally
      //
      // If local zone was 65% utilization:
      // - Difference: 65% - 55% = 10% (exceeds threshold) → Distribute traffic
      //
      // Default: 0.05 (5%). Set to 0.0 to only route locally when local zone has
      // the absolute lowest utilization.
      type.v3.Percent locality_direct_threshold = 6;

      // Exponential moving average (EMA) smoothing factor for zone metrics.
      // When calculating zone-level ORCA metrics, use EMA to smooth rapid fluctuations:
      //   new_avg = alpha × current_measurement + (1 - alpha) × previous_avg
      //
      // Higher values (closer to 1.0) respond faster to changes but are more sensitive to noise.
      // Lower values (closer to 0.0) are more stable but slower to respond to real changes.
      //
      // Typical values:
      //   0.3-0.5: Responsive to changes, some smoothing
      //   0.1-0.2: Stable, dampens fluctuations (recommended)
      //   0.0: No smoothing (use raw measurements)
      //
      // Default: 0.2 (20% weight to new measurements)
      google.protobuf.DoubleValue zone_metrics_smoothing_factor = 7
          [(validate.rules).double = {gte: 0.0, lte: 1.0}];

      // Minimum time to wait before using newly calculated zone routing weights.
      // This provides stability by preventing rapid changes in routing decisions.
      // Aligns with client-side weighted round robin's blackout_period concept.
      // Default: 10 seconds (same as CSWRR).
      google.protobuf.Duration blackout_period = 8;

      // Whether to enable out-of-band utilization reporting collection from endpoints.
      // By default, per-request utilization reporting via LoadMetricStats is used.
      // When enabled, endpoints can proactively send ORCA metrics on a periodic basis,
      // reducing per-request overhead and providing more timely load information.
      // Default: false (per-request mode).
      google.protobuf.BoolValue enable_oob_load_report = 9;

      // Load reporting interval to request from endpoints when using out-of-band reporting.
      // Note that endpoints may not provide reports as frequently as requested.
      // Only used when enable_oob_load_report is true.
      // Default: 10 seconds (same as CSWRR).
      google.protobuf.Duration oob_reporting_period = 10;

      // If a zone has not received out-of-band ORCA metrics in this long,
      // then we stop using the reported metrics and fall back to per-request
      // LoadMetricStats or host counts. This ensures that we do not continue
      // to use very stale metrics for routing decisions.
      // Once we stop using stale metrics, if fresh OOB reports resume,
      // the blackout_period applies before metrics are used again.
      // Only used when enable_oob_load_report is true.
      // Default: 3 minutes (same as CSWRR weight_expiration_period).
      google.protobuf.Duration oob_expiration_period = 11;

      // === OOB-First Mode Configuration ===
      // These fields enable intelligent cross-zone probe elimination

      // Whether to enable OOB-first mode that prioritizes cached metrics over probing.
      // In OOB-first mode, cross-zone probes are only sent when absolutely necessary.
      // Default: false (traditional probing behavior).
      google.protobuf.BoolValue enable_oob_first_mode = 12;

      // Strategy for handling missing or stale OOB data.
      enum OobFallbackStrategy {
        // Always fallback to cross-zone probing (traditional behavior)
        PROBE_FALLBACK = 0;

        // Use last known good metrics until they expire completely
        USE_STALE_METRICS = 1;

        // Use estimated metrics based on historical patterns
        USE_ESTIMATED_METRICS = 2;

        // Hybrid: try limited probing, then use stale/estimated
        HYBRID_FALLBACK = 3;
      }
      OobFallbackStrategy oob_fallback_strategy = 13;

      // Conditions that trigger cross-zone probing in OOB-first mode.
      // Only used when enable_oob_first_mode is true.
      message ProbeTriggers {
        // Trigger probing if OOB data is missing for this duration
        google.protobuf.Duration oob_missing_threshold = 1;

        // Trigger probing if load variance between zones exceeds this percentage
        // Value is 0.0 to 1.0 (e.g., 0.2 = 20% variance threshold)
        google.protobuf.DoubleValue load_variance_threshold = 2;

        // Trigger probing when a new zone is detected
        bool new_zone_detected = 3;

        // Maximum number of cross-zone probes allowed per minute
        // Rate limiting to prevent probe storms
        google.protobuf.UInt32Value max_probes_per_minute = 4;

        // Only probe zones with significant traffic difference
        google.protobuf.DoubleValue traffic_difference_threshold = 5;
      }
      ProbeTriggers probe_triggers = 14;

      // Zone-level metrics aggregation configuration
      message ZoneAggregationConfig {
        // Whether to aggregate metrics at zone level instead of host level
        bool enable_zone_aggregation = 1;

        // Minimum number of hosts reporting in a zone for aggregation to be valid
        google.protobuf.UInt32Value min_hosts_per_zone = 2;

        // Aggregation method for zone metrics
        enum AggregationMethod {
          // Use average of all host metrics in zone
          AVERAGE = 0;

          // Use weighted average based on host capacity
          WEIGHTED_AVERAGE = 1;

          // Use maximum value (most conservative)
          MAXIMUM = 2;

          // Use minimum value (most optimistic)
          MINIMUM = 3;
        }
        AggregationMethod aggregation_method = 3;

        // Whether to prioritize local zone metrics in calculations
        bool prioritize_local_zone = 4;

        // Weight factor for local zone when prioritized (1.0 = normal, >1.0 = preferred)
        google.protobuf.DoubleValue local_zone_weight = 5;
      }
      ZoneAggregationConfig zone_aggregation = 15;
    }

    // Configuration for ORCA-based load measurement.
    // Only used when locality_basis is set to ORCA_LOAD.
    // If locality_basis is ORCA_LOAD but this is not set, default values are used.
    OrcaLoadBasedConfig orca_load_config = 7;
  }

  // Configuration for :ref:`locality weighted load balancing
  // <arch_overview_load_balancing_locality_weighted_lb>`
  message LocalityWeightedLbConfig {
  }

  oneof locality_config_specifier {
    option (validate.required) = true;

    // Configuration for local zone aware load balancing.
    ZoneAwareLbConfig zone_aware_lb_config = 1;

    // Enable locality weighted load balancing.
    LocalityWeightedLbConfig locality_weighted_lb_config = 2;
  }
}

// Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
message SlowStartConfig {
  // Represents the size of slow start window.
  // If set, the newly created host remains in slow start mode starting from its creation time
  // for the duration of slow start window.
  google.protobuf.Duration slow_start_window = 1;

  // This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
  // so that endpoint would get linearly increasing amount of traffic.
  // When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
  // The value of aggression parameter should be greater than 0.0.
  // By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
  //
  // During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
  // ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
  // where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
  //
  // As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
  // Once host exits slow start, time_factor and aggression no longer affect its weight.
  config.core.v3.RuntimeDouble aggression = 2;

  // Configures the minimum percentage of origin weight that avoids too small new weight,
  // which may cause endpoints in slow start mode receive no traffic in slow start window.
  // If not specified, the default is 10%.
  type.v3.Percent min_weight_percent = 3;
}

// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
message ConsistentHashingLbConfig {
  // If set to ``true``, the cluster will use hostname instead of the resolved
  // address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
  bool use_hostname_for_hashing = 1;

  // Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
  // no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
  // If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
  // Minimum is 100.
  //
  // Applies to both Ring Hash and Maglev load balancers.
  //
  // This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
  // ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
  // across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
  // is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
  // the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
  // cascading overflow effect when choosing the next host in the ring/table).
  //
  // If weights are specified on the hosts, they are respected.
  //
  // This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
  // being probed, so use a higher value if you require better performance.
  google.protobuf.UInt32Value hash_balance_factor = 2 [(validate.rules).uint32 = {gte: 100}];

  //  Specifies a list of hash policies to use for ring hash load balancing. If ``hash_policy`` is
  // set, then
  // :ref:`route level hash policy <envoy_v3_api_field_config.route.v3.RouteAction.hash_policy>`
  // will be ignored.
  repeated config.route.v3.RouteAction.HashPolicy hash_policy = 3;
}
